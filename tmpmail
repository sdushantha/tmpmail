#!/usr/bin/env sh
#
# by Siddharth Dushantha 2020
#
# Dependencies: jq, curl, w3m
#
set -u  # enable interpreter to catch spelling mistakes of variables
VERSION=1.1.2

# By default 'tmpmail' uses 'w3m' as its web browser to render
# the HTML of the email
BROWSER="w3m"

# If the value is set to 'true' tmpmail will convert the HTML email
# to raw text and send that to stdout
RAW_TEXT=false

# Everything related to 'tmpmail' will be stored in /tmp/tmpmail
# so that the old emails and email addresses get cleared after
# restarting the computer
TMPMAIL_DIR="/tmp/tmpmail"

# TMP_ADDRESS_FILE is where we store the temporary email address that gets
# generated. This prevents the user from providing the email address
# everytime tmpmail is run
TMP_ADDRESS_FILE="$TMPMAIL_DIR/email_address"

# tmpmail.html is where the email gets stored.
# Even though the file ends with a .html extension, the raw text version of
# the email will also be stored in this file so that w3m and other browsers
# are able to open this file
TMPMAIL_HTML_EMAIL="$TMPMAIL_DIR/tmpmail.html"

# Default 1secmail API URL
TMPMAIL_API_URL="https://www.1secmail.com/api/v1/"

# Making '{' the first character of a line makes it very easy to search for
# the start of every function.  For example, grep '^{' or in less, /^\{
usage()
{ cat <<EOF
tmpmail
tmpmail -h | --version
tmpmail -g [ADDRESS]
tmpmail [-t | -b BROWSER] -r | ID

When called with no option and no argument, tmpmail lists the messages in
the inbox and their numeric IDs.  When called with one argument, tmpmail
shows the email message with specified ID.

-b, --browser BROWSER
        Specify BROWSER (default: w3m) that is used to render the HTML of
        the email
-g, --generate [ADDRESS]
        Generate a new email address, either the specified ADDRESS, or
        randomly create one
-h, --help
        Show help
-r, --recent
        View the most recent email message
-t, --text
        View the email as raw text, where all the HTML tags are removed.
        Without this option, HTML is used.
--version
        Show version
EOF
}

generate_email_address()
{
    # There are 2 ways which this function is called in this script.
    #  [1] The user wants to generate a new email and runs 'tmpmail --generate'
    #  [2] The user runs 'tmpmail' to check the inbox , but /tmp/tmpmail/email_address
    #      is empty or nonexistant. Therefore a new email gets automatically
    #      generated before showing the inbox. But of course the inbox will
    #      be empty as the newly generated email address has not been
    #      sent any emails.
    #
    # When the function 'generate_email_address()' is called with the argument
    # 'true', it means that the function was called because the user
    # ran 'tmpmail --generate'.
    #
    # We need this variable so we can know whether or not we need to show the user
    # what the email was. <-- More about this can be found further down in this function.
    EXTERNALLY=${1:-false}

    # This variable lets generate_email_address know if the user has provided a custom
    # email address which (s)he wants to use
    CUSTOM=${2:-false}

    # Generate a random email address.
    # This function is called whenever the user wants to generate a new email
    # address by running 'tmpmail --generate' or when the user runs 'tmpmail'
    # but /tmp/tmpmail/email_address is empty or nonexistent.

    # Valid top level domains which 1secmail provides
    TLDS="com|net|org"

    # If the user provided a custom email address then use that email address
    if [ "$CUSTOM" != false ]; then
        EMAIL_ADDRESS="$CUSTOM"
    else  # Create a random username
        # Take first 10 lines from /dev/urandom; delete all characters
        # which are *not* alphanumeric (exclude punctuation etc.); take the
        # first 10 characters; convert uppercase to lowercase
        USERNAME=$(head /dev/urandom | LC_ALL=C tr -dc "[:alnum:]" | head -c10 | tr "[:upper:]" "[:lower:]")
        # Randomly pick one of the TLDS mentiond above.
        TLD=$(printf %s "$TLDS" | tr '|' '\n' | shuf -n 1)
        EMAIL_ADDRESS="$USERNAME@1secmail.$TLD"
    fi

    # Check that the email address is valid
    REGEXP="[a-z0-9]+@1secmail\.($TLDS)"
    if ! printf %s "$EMAIL_ADDRESS" | grep -Eq "$REGEXP"; then
        print_error "Email address '$EMAIL_ADDRESS' is invalid; it must match regexp '$REGEXP'."
    fi

    # Save the generated email address to $TMP_ADDRESS_FILE so that it can
    # be read whenever 'tmpmail' is run
    printf %s "$EMAIL_ADDRESS" >"$TMP_ADDRESS_FILE"

    # If this function was called because the user wanted to generate a new
    # email address, show the email address
    [ "$EXTERNALLY" = true ] && cat "$TMP_ADDRESS_FILE"
}

get_email_address()
{
    # This function is only called once and that is when this script
    # get executed. The output of this function gets stored in $EMAIL_ADDRESS
    #
    # If the file that contains the email address is empty,
    # that means we do not have an email address, so generate one.
    [ ! -s "$TMP_ADDRESS_FILE" ] && generate_email_address

    # Output the email address by getting the first line of $TMPMAIL_EMAIL
    head -n 1 "$TMP_ADDRESS_FILE"
}

# List all the received emails in a nicely formatted order
list_emails()
{
    DATA=$(curl -sL "${TMPMAIL_API_URL}?action=getMessages&login=$USERNAME&domain=1secmail.$TLD")
    DATA_LENGTH=$(printf %s "$DATA" | jq length)  # number of messages
    printf "[ Inbox for %s ]\n\n" "$EMAIL_ADDRESS"
    [ "$DATA_LENGTH" -eq 0 ] && echo "No new mail" && exit

    # This is where we store all of our emails, which is then
    # displayed using 'column'
    INBOX=""
    for index in $(seq 1 "$DATA_LENGTH"); do
        # arrays in JSON start at 0, so subtract one from $index
        MAIL_DATA=$(printf %s "$DATA" | jq -r ".[$index-1]")

        ID=$(     printf %s "$MAIL_DATA" | jq -r ".id")
        FROM=$(   printf %s "$MAIL_DATA" | jq -r ".from")
        SUBJECT=$(printf %s "$MAIL_DATA" | jq -r ".subject")

        INBOX="$INBOX$ID ||$FROM ||$SUBJECT\n"
    done
    printf "%b" "$INBOX" | column -t -s "||"
}

# Arg 1 ($1) is the ID of the email message
view_email()
{
    EMAIL_ID="$1"
    DATA=$(curl -sL "${TMPMAIL_API_URL}?action=readMessage&login=$USERNAME&domain=1secmail.$TLD&id=$EMAIL_ID")
    [ "$DATA" = "Message not found" ] && print_error "Message not found"

    FROM=$(     printf %s "$DATA" | jq -r ".from")
    SUBJECT=$(  printf %s "$DATA" | jq -r ".subject")
    HTML_BODY=$(printf %s "$DATA" | jq -r ".htmlBody")

    # If you get an email that is in pure text, the .htmlBody field will be empty and
    # we will need to get the content from .textBody instead
    [ -z "$HTML_BODY" ] && HTML_BODY="<pre>$(printf %s "$DATA" | jq -r ".textBody")</pre>"

    HTML_MAIL=$(cat <<EOF
<pre><b>To: </b>$EMAIL_ADDRESS
<b>From: </b>$FROM
<b>Subject: </b>$SUBJECT</pre>
$HTML_BODY
EOF
)
    printf %s "$HTML_MAIL" > "$TMPMAIL_HTML_EMAIL"
    if [ "$RAW_TEXT" = true ]; then
        w3m -dump "$TMPMAIL_HTML_EMAIL"
    else
        $BROWSER "$TMPMAIL_HTML_EMAIL"
    fi
}

view_latest_email()
{ view_email $(list_emails | sed -n 3p | cut -d' ' -f 1); }

# Arg 1 ($1) is the error message to print to stderr
print_error()
{ printf "%s: Error: %s\n" "$0" "$1" >&2; exit 1; }

main()
{
    for dependency in jq w3m curl; do   # required programs
        if ! command -v "$dependency" >/dev/null 2>&1; then
            print_error "Could not find '$dependency', is it installed?"
        fi
    done

    mkdir -p "$TMPMAIL_DIR"
    EMAIL_ADDRESS="$(get_email_address)"

    # ${VAR#PATTERN} Removes shortest match of pattern from start of a string.
    # In this case, it takes the EMAIL_ADDRESS and removed everything after
    # the '@' symbol which gives us the username.
    USERNAME=${EMAIL_ADDRESS%@*}

    # ${VAR%PATTERN} Remove shortest match of pattern from end of a string.
    # In this case, it takes the EMAIL_ADDRESS and removes everything until the
    # period '.' which gives us the Top Level Domain
    TLD=${EMAIL_ADDRESS#*.}

    while [ $# -gt 0 ]; do
        case "$1" in
            --browser | -b)
                if [ $# -ge 2 ]; then BROWSER="$2"; shift
                else print_error "option $1 is missing its argument"
                fi ;;
            --generate | -g)
                [ $# -ge 2 ] && addr="$2" || addr=""
                generate_email_address true "$addr"
                exit ;;
            --help | -h)
                usage
                exit ;;
            --recent | -r)
                view_latest_email
                exit ;;
            --text | -t)
                RAW_TEXT=true ;;
            --version)
                echo "$VERSION"
                exit ;;
            -*)
                print_error "unrecognized option '$1'" ;;
            *[0-9]*)
                # If the user provides number as an argument,
                # assume it is the ID of an email and try getting
                # the email that belongs to the ID
                view_email "$1"
                exit ;;
            *)
                print_error "unrecognized argument '$1'" ;;
        esac
        shift
    done
    list_emails
}

main "$@"
